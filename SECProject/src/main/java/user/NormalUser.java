package user;

import java.io.File;
import java.io.IOException;
import java.security.Key;
import java.security.PublicKey;
import java.sql.Time;
import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.ini4j.Ini;
import org.ini4j.InvalidFileFormatException;
import com.user.grpc.UserService.LocProofRep;
import com.user.grpc.UserService.LocProofReq;
import com.user.grpc.UserService.Position;
import com.user.grpc.userServiceGrpc;
import com.user.grpc.userServiceGrpc.userServiceStub;
import com.server.grpc.serverServiceGrpc;
import com.server.grpc.serverServiceGrpc.serverServiceBlockingStub;
import com.server.grpc.serverServiceGrpc.serverServiceStub;
import com.google.gson.JsonObject;
import com.server.grpc.ServerService.secureReplay;
import com.server.grpc.ServerService.secureRequest;
import io.grpc.*;
import io.grpc.stub.StreamObserver;
import crypto.RSAProvider;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.Server;
import io.grpc.ServerBuilder;
import shared.Point2D;
import shared.TrackerLocationSystem;

public class NormalUser extends User {
	
	//distance that user consider to see if a user is near him
	private final double closer_range_dist = 2;
	

	private int port;
	private int server_start_port;
	private int num_servers;
	private int num_byzantines;
	private int quorum;
	
	/**************************************************************************************
	* 											-User class constructor()
	* - 
	 * @throws IOException 
	 * @throws InvalidFileFormatException 
	* 
	* ************************************************************************************/
	public NormalUser(int ID) throws Exception {
		super(ID, "user");
		this.port = ID + Integer.parseInt("9090");
		this.server_start_port = new Ini(new File("variables.ini")).get("Server","server_start_port", Integer.class);
		this.num_servers = new Ini(new File("variables.ini")).get("Server","number_of_servers", Integer.class);
		this.num_byzantines = new Ini(new File("variables.ini")).get("Server","number_of_byzantines", Integer.class);
		this.quorum = (num_servers+num_byzantines)/2;
		init();
		initThreadToSndReqProof();
	}

	/**************************************************************************************
	 * 											-init()
	 * - init user server to receive proof location request in port given in the constructor
	 * and use localhost as IP
	 * 
	 * ************************************************************************************/
	private void init() {
		 Runnable r =	new Runnable() {
				@Override
				public void run() {
					Server userServer = ServerBuilder.forPort(port).addService(new UserServiceImp(getMyID(), getPRIVATE_KEY_PATH())).build();
					try {
						userServer.start();
						System.out.println("user " + myID + " server start at " + userServer.getPort());
						
						userServer.awaitTermination();
					} catch (IOException | InterruptedException e) {
						e.printStackTrace();
					}
					
				}
			};
			
			new Thread(r).start();
			
		}
	
	/**************************************************************************************
	 * 										-sndProofRequest()
	 * -send proof location request to all user in the channel(this user 
	 * 	are considered users near him). before sending each message it computes the
	 *  digital signature of the message and before considering that the user is near
	 *   or not it verifies the signature of the witness message. if it holds
	 *    then it puts the prove  the list and returns it. 
	 * 
	 * -input
	 * 		- channels: list of user channel to send location proof request
	 * 		- ID: ID of the user who pretend to proof his location
	 * 		- epoch: epoch which user want to proof his location
	 * 		- x,y: Location where user want to be prooved.
	 * @throws Exception generated by readprivatekey function in
	 * 	 rsaprovider class when the path of the private key is not found.
	 * 
	 * - return: List<string>( where each string is the proof of the witness 
	 * 	that the user is actually near him).
	 * 
	 * ************************************************************************************/
	public List<String> sndProofRequest(List<ManagedChannel> channels, int ID, int epoch, Point2D proverPos) throws Exception {

		final CountDownLatch finishLatch = new CountDownLatch(channels.size());
		List<String> proofs = new ArrayList<>();
		StreamObserver<LocProofRep> replyObserver = new StreamObserver<LocProofRep>() {
		
			@Override
			public void onNext(LocProofRep reply) {
				try {
					String witnessProof = reply.getProof();
					String witnessProofDigSig = reply.getProofDigSig();
					PublicKey witPubKey = TrackerLocationSystem.getUserPublicKey(reply.getWitnessID(), "user");
					boolean proofIsAuth = RSAProvider.istextAuthentic(witnessProof, witnessProofDigSig, witPubKey);
					if(proofIsAuth)
						proofs.add(reply.getProof());
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}

			@Override
			public void onError(Throwable t) {
				Status status = Status.fromThrowable(t);
				System.out.println("[user" + ID + "] Error: " + status);
				finishLatch.countDown();
			}

			@Override
			public void onCompleted() {
				finishLatch.countDown();
				
			}
		};
		userServiceStub userAsyncStub;
		Position.Builder pos = Position.newBuilder().setX(proverPos.getX()).setY(proverPos.getY());
		for(ManagedChannel channel : channels) {
			String sig = signMessage(ID +" "+ epoch +" "+ proverPos.toString());
			userAsyncStub = userServiceGrpc.newStub(channel).withDeadlineAfter(5, TimeUnit.SECONDS);
					LocProofReq req = LocProofReq.newBuilder().setProverID(ID)
									 		.setEpoch(epoch).setLoc(pos).setDigSign(sig).build();
					userAsyncStub.requestLocationProof(req, replyObserver);
		}
		finishLatch.await();
		for(ManagedChannel channel : channels)
			channel.shutdown();
		return proofs;
	}

	/**************************************************************************************
	 * 										-submitLocationReport()
	 *	- send location report to the server
	 *
	 * -input
	 * 		- proofs: list of user's proofs gathered using sndProofRequest() method
	 * 		- ID: ID of the user who report his location
	 * 		- epoch: epoch which user want to report his location
	 * 		- x,y: Location of user to report
	 *
	 * - return: True if quorum submitted a report
	 * @throws Exception 
	 *
	 * ************************************************************************************/
	public boolean submitLocationReport(List<String> proofs, int ID, int epoch, Point2D position) throws Exception {
		List<Integer> nonces = new ArrayList<>();

		// submitLocationReport callback
		Set<Integer> acks = new HashSet<>();
		final CountDownLatch finishLatch = new CountDownLatch(this.num_servers);
		StreamObserver<secureReplay> acksObserver = new StreamObserver<secureReplay>() {
			@Override
			public void onNext(secureReplay reply) {
				int serverID = reply.getServerID();
				if (acks.contains(serverID)) { // This server's already sent ack; ignore it
					return;
				}

				String[] replyFields = new String[0];
				try {
					replyFields = getfieldsFromSecureMessage(serverID, reply.getConfidentMessage(),
																	  reply.getMessageDigitalSignature());
				} catch (Exception e) { // Message is not authenticated
					System.out.println(e.getMessage());
					return;
				}

				int serverNonce = Integer.parseInt(replyFields[1]);
				if(serverNonce != nonces.get(serverID)-1) {
					System.out.println("[user" + ID + "] Submit Report Error: Unexpected nonce");
					return;
				}

				System.out.println("From server" + serverID + ": " + replyFields[0]);

				// Everything OK, accept this ack
				// Set is used to ignore more acks from single server
				acks.add(serverID);
				finishLatch.countDown();
			}

			@Override
			public void onError(Throwable t) {
				Status status = Status.fromThrowable(t);
				System.out.println("[user" + ID + "] Submit Report Error: " + status);
				finishLatch.countDown();
			}

			@Override
			public void onCompleted() { }
		};

		// Send submit report request to each server
		List<ManagedChannel> serverChannels = new ArrayList<>();
		serverServiceStub serverAsyncStub;

		String message = proofs.toString();// + "||" + epoch;
		String signedMessage = signMessage(message);

		// Find number that sha-256(proofs+numer) starts with 20 zeros
		int myNonce = hashCash(message);
		ManagedChannel channel;

		for(int server_id = 0; server_id < this.num_servers; server_id++) {
//			int myNonce = new Random().nextInt();
			nonces.add(myNonce); // Store to verify in a reply

//			String message = proofs.toString() + "||" + epoch +"||" + myNonce;
//			JsonObject secureMessage = getsecureMessage(server_id, message);
//			String messagecipher = secureMessage.get("ciphertext").getAsString();
//			String messageDigSig = secureMessage.get("textDigitalSignature").getAsString();
			String encryptedMessage = encryptMessage(server_id, message + "||" + myNonce);

			channel = ManagedChannelBuilder.forAddress("127.0.0.1", server_start_port+server_id)
					                       .usePlaintext().build();
			serverChannels.add(channel); // Store it for a proper close later
			serverAsyncStub = serverServiceGrpc.newStub(channel).withDeadlineAfter(10, TimeUnit.SECONDS)
																.withWaitForReady();

			secureRequest submitRequest = secureRequest.newBuilder().setUserID(ID)
													  				.setConfidentMessage(encryptedMessage)
													  				.setMessageDigitalSignature(signedMessage).build();
			serverAsyncStub.submitLocationReport(submitRequest, acksObserver);
		}

		// Wait for all replies (both errors and ok)
		finishLatch.await();

		// Close channels
		for(ManagedChannel ch : serverChannels)
			ch.shutdown();

		// Set acks now contains ids of servers accepted the submit request
		return acks.size() > this.quorum;
	}

	/**************************************************************************************
	 * 											-getCloserUsers()
	 * - returns the channel of the user that are closer to him in a given epoch 
	 * in order to send them Proof Location request.
	 * 
	 *-input
	 *			-epoch: the epoch of user use to get closer users.
	 *
	 *- returns: list of users channel. 
	 * 
	 * ************************************************************************************/
	public List<ManagedChannel> getCloserUsers(int epoch) throws IOException{
		List<UserLocation> usersInEpoch = TrackerLocationSystem.getAllUsersInEpoch(epoch);
		List<ManagedChannel> closerChannel = new ArrayList<>();
		UserLocation myPosInEpoch = TrackerLocationSystem.getPosInEpoc(getMyID(), epoch);
		for(UserLocation u: usersInEpoch) {
			if(u.getUserId() != getMyID()) {
				Point2D u_point = u.getPosition();
				double dist = myPosInEpoch.getPosition().distance(u_point);
				if( dist <= closer_range_dist ) {
					ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", u.getPort()).usePlaintext().build();
					closerChannel.add(channel);
				}
			}
		}
		return closerChannel;	
	}
	
	public boolean proveLocation(int epoch) throws Exception {
		List<String> proofs;
		Point2D myCurrentPoosition = TrackerLocationSystem.getPosInEpoc(getMyID(), epoch).getPosition();
		List<ManagedChannel> closerChannel = getCloserUsers(epoch);
		proofs = sndProofRequest(closerChannel, getMyID(), epoch, myCurrentPoosition);

		// Send submitReport request to all servers asynchronously
		return submitLocationReport(proofs, getMyID(), epoch, myCurrentPoosition);
	}
	
	/**************************************************************************************
	 * 											-initThreadToUpdFilePos()
	 * - this procedure start a thread that will run in a loop to update the
	 *   user position in the grid file. 
	 *   before updating the user position the thread sleep between 10 to 15sec.
	 *   when thread finish to update position it send proof request to user near him.
	 *
	 * 
	 *-input
	 *
	 *- returns: void
	 * 
	 * ************************************************************************************/
	private void initThreadToSndReqProof(){
		Runnable r = new Runnable() {
			@Override
			public void run() {
			int sleepTime, myCurrentEpoch = 0;
			while(true) {
				try {
						sleepTime = (int)(Math.random()*15000 + 15000); //time to sleep between 15s-30s
						Thread.sleep(sleepTime);
						myCurrentEpoch = myCurrentEpoch%10 + 1;

						boolean submitStatus = proveLocation(myCurrentEpoch);
						if (submitStatus) System.out.println("user ID = "+getMyID()+", report submitted");
						else System.out.println("user ID = "+getMyID()+", report was NOT submitted");

						Thread.sleep(1000);
						String reply =  obtainLocationReport(myCurrentEpoch);
						System.out.println("user "+ getMyID() +" position at epoch "+ myCurrentEpoch +": "+ reply);
				} catch (Exception e) {
					System.out.println(e.getMessage());
					//e.printStackTrace();
				}
				
			}
		}
	};
		
	new Thread(r).start();
	}
	
	public String obtainLocationReport(int epoch) throws Exception {
		List<Integer> nonces = new ArrayList<>();
		List<ManagedChannel> serverChannels = new ArrayList<>();
		Map<String, Integer> readvals = new HashMap<>();
		Set<Integer> acks = new HashSet<>();

		serverServiceStub serverAsyncStub;
		final CountDownLatch finishLatch = new CountDownLatch(this.num_servers);
		StreamObserver<secureReplay> responseObserver = new StreamObserver<secureReplay>() {
			@Override
			public void onNext(secureReplay secureReplay) {
				int serverID = secureReplay.getServerID();
				if (acks.contains(serverID))
					return;

				String[] replyFields = new String[0];
				try {
					// {userid, point, nonce}
					replyFields = getfieldsFromSecureMessage(serverID,
							secureReplay.getConfidentMessage(), secureReplay.getMessageDigitalSignature());
				} catch (Exception e) {
					System.out.println(e.getMessage());
					return;
				}

				int serverNonce = Integer.parseInt(replyFields[replyFields.length-1]);
				if(serverNonce != nonces.get(serverID)-1) {
					System.out.println("[user" + myID + "] Submit Report Error: Unexpected nonce");
					return;
				}

				String location = replyFields[1];

				acks.add(serverID);
				if (!readvals.containsKey(location)) {
					readvals.put(location, 1);
				}

				readvals.put(location, readvals.get(location) + 1);
				finishLatch.countDown();
			}

			@Override
			public void onError(Throwable t) {
				Status status = Status.fromThrowable(t);
				System.out.println("[user" + myID + "] Submit Report Error: " + status);
				finishLatch.countDown();
			}

			@Override
			public void onCompleted() { }
		};


		for (int server_id = 0; server_id < num_servers; ++server_id) {
			ManagedChannel channel = ManagedChannelBuilder.forAddress("127.0.0.1", server_start_port + server_id)
					.usePlaintext().build();
			int myNonce = new Random().nextInt();
			nonces.add(myNonce);
			serverChannels.add(channel);

			String message = getMyID() + "||" + epoch +"||"+myNonce;
			JsonObject cipherReq  = getsecureMessage(server_id, message);
			String cipherText = cipherReq.get("ciphertext").getAsString();
			String digSig = cipherReq.get("textDigitalSignature").getAsString();
			secureRequest req = secureRequest.newBuilder().setConfidentMessage(cipherText).setUserID(getMyID()).
					setMessageDigitalSignature(digSig).build();

			serverAsyncStub = serverServiceGrpc.newStub(channel).withDeadlineAfter(10, TimeUnit.SECONDS)
					.withWaitForReady();

			serverAsyncStub.obtainLocationReport(req, responseObserver);
		}

		finishLatch.await();

		for(ManagedChannel channel : serverChannels)
			channel.shutdown();

		if (readvals.size() <= quorum) {
			throw new Exception("Not enough answers");
		}

		Integer max = 0;
		String consensus = "";
		for (Map.Entry<String, Integer> entry : readvals.entrySet()) {
			if (entry.getValue() > max) {
				max = entry.getValue();
				consensus = entry.getKey();
			}
		}

		return consensus;
	}
	
	
}